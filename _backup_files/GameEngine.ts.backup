import type { Controls, GameState, RoadSegment } from '../types/game';
import { AudioManager } from './AudioManager';
import { LandscapeGenerator } from './LandscapeGenerator';

export class GameEngine {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private gameState: GameState;
    private controls: Controls;
    private lastTime: number = 0;
    private animationId: number | null = null;
    private landscapeGenerator: LandscapeGenerator;
    private audioManager: AudioManager;
    private lastBrakeState: boolean = false;

    // Game constants
    private readonly ROAD_WIDTH = 400;
    private readonly SEGMENT_LENGTH = 200;
    private readonly CAMERA_HEIGHT = 1000;
    private readonly CAMERA_DEPTH = 1 / Math.tan((Math.PI / 180) * 30); // FOV 30 degrees
    private readonly DRAW_DISTANCE = 300; constructor(canvas: HTMLCanvasElement) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d')!;
        this.landscapeGenerator = new LandscapeGenerator();
        this.audioManager = new AudioManager();

        this.controls = {
            left: false,
            right: false,
            brake: false
        };

        this.gameState = this.initializeGameState();
        this.setupCanvas();
        this.loadAssets();
    }
    private async loadAssets() {
        // Load car sprite
        const carSprite = new Image();
        carSprite.src = '/outrun-racer/images/car.png';

        carSprite.onload = () => {
            this.gameState.car.sprite = carSprite;
            console.log('Car sprite loaded successfully');
        };

        carSprite.onerror = (err) => {
            console.error('Error loading car sprite:', err);
            // Try with alternative path if base path fails (for local development)
            const altCarSprite = new Image();
            altCarSprite.src = 'images/car.png';

            altCarSprite.onload = () => {
                this.gameState.car.sprite = altCarSprite;
                console.log('Car sprite loaded from alternative path');
            };
        };
    }

    private initializeGameState(): GameState {
        return {
            car: {
                position: { x: 0, y: 0 },
                speed: 0,
                maxSpeed: 200,
                acceleration: 50,
                deceleration: 20,
                brakeForce: 80,
                steerDirection: 0,
                sprite: null
            },
            road: this.generateRoad(),
            landscape: [],
            camera: { x: 0, y: 1000, z: 0 },
            speed: 0,
            distance: 0,
            score: 0,
            isPlaying: false,
            isPaused: false
        };
    }

    private setupCanvas() {
        const resizeCanvas = () => {
            const container = this.canvas.parentElement!;
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
        };

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    }

    private generateRoad(): RoadSegment[] {
        const road: RoadSegment[] = [];
        let y = 0;

        for (let i = 0; i < 1000; i++) {
            road.push({
                curve: Math.sin(i / 30) * 0.02 + Math.sin(i / 50) * 0.01,
                y: y,
                worldY: i * this.SEGMENT_LENGTH
            });

            // Add some hills
            if (i % 100 === 0) {
                y += (Math.random() - 0.5) * 200;
            }
        }

        return road;
    }

    public setControls(controls: Partial<Controls>) {
        this.controls = { ...this.controls, ...controls };
    }
    public start() {
        this.gameState.isPlaying = true;
        this.audioManager.ensureAudioContext();
        this.audioManager.playBackgroundMusic();
        this.gameLoop(0);
    }

    public pause() {
        this.gameState.isPaused = !this.gameState.isPaused;
    }

    public stop() {
        this.gameState.isPlaying = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }

    private gameLoop = (currentTime: number) => {
        if (!this.gameState.isPlaying) return;

        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;

        if (!this.gameState.isPaused) {
            this.update(deltaTime);
        }

        this.render();
        this.animationId = requestAnimationFrame(this.gameLoop);
    };
    private update(deltaTime: number) {
        this.updateCar(deltaTime);
        this.updateCamera();
        this.updateScore();
        this.updateLandscape();
    }
    private updateLandscape() {
        // Generate new landscape objects as we move
        this.gameState.landscape = this.landscapeGenerator.generateLandscape(
            this.gameState.distance
        );
    }
    private updateCar(deltaTime: number) {
        const car = this.gameState.car;

        // Handle steering
        if (this.controls.left) {
            car.steerDirection = Math.max(-1, car.steerDirection - 3 * deltaTime);
        } else if (this.controls.right) {
            car.steerDirection = Math.min(1, car.steerDirection + 3 * deltaTime);
        } else {
            car.steerDirection *= 0.9; // Return to center
        }

        // Handle acceleration/braking with audio
        if (this.controls.brake) {
            car.speed = Math.max(0, car.speed - car.brakeForce * deltaTime);

            // Play brake sound when starting to brake
            if (!this.lastBrakeState) {
                this.audioManager.playSound('brake');
            }
        } else {
            car.speed = Math.min(car.maxSpeed, car.speed + car.acceleration * deltaTime);

            // Play engine sound when accelerating from low speed
            if (car.speed < 50 && car.speed + car.acceleration * deltaTime >= 50) {
                this.audioManager.playSound('engine');
            }
        }

        // Update brake state for audio
        this.lastBrakeState = this.controls.brake;

        // Apply steering to position
        car.position.x += car.steerDirection * car.speed * deltaTime * 0.01;

        // Keep car on road
        car.position.x = Math.max(-1, Math.min(1, car.position.x));

        // Update distance
        this.gameState.distance += car.speed * deltaTime;
    }

    private updateCamera() {
        const car = this.gameState.car;
        this.gameState.camera.x = car.position.x;
        this.gameState.camera.z = this.gameState.distance;
    }

    private updateScore() {
        this.gameState.score = Math.floor(this.gameState.distance / 10);
    }
    private render() {
        this.clearScreen();
        this.renderSky();
        this.renderMountains();
        this.renderLandscape();
        this.renderRoad();
        this.renderCar();
        this.renderHUD();
    }

    private clearScreen() {
        this.ctx.fillStyle = '#87CEEB'; // Sky blue
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }    private renderSky() {
        // Enhanced gradient sky with time-based colors and atmospheric effects
        const timeOfDay = (this.gameState.distance * 0.001) % 24;
        let skyColor1, skyColor2, skyColor3, horizonColor;
        let sunMoonVisible = true;
        let sunMoonColor = '#FFFFFF';
        let sunMoonGlow = 'rgba(255, 255, 255, 0.2)';
        let sunMoonSize = 40;
        let sunMoonPosition = {
            x: this.canvas.width * 0.8,
            y: this.canvas.height * 0.2
        };
        
        // Stars for night sky
        let starsVisible = false;
        
        // Cloud parameters
        let cloudColor = 'rgba(255, 255, 255, 0.8)';
        let cloudShadow = 'rgba(0, 0, 0, 0.1)';

        if (timeOfDay < 5 || timeOfDay > 21) {
            // Night
            skyColor1 = '#0B0B2D'; // Deep night blue at the top
            skyColor2 = '#162447'; // Night blue in the middle
            skyColor3 = '#1D3E6E'; // Lighter night blue toward horizon
            horizonColor = '#2A5586'; // Dark blue horizon glow
            
            // Moon properties
            sunMoonColor = '#F8F8FF';
            sunMoonGlow = 'rgba(255, 255, 255, 0.3)';
            sunMoonSize = 35;
            sunMoonPosition = {
                x: this.canvas.width * (0.5 + Math.cos(timeOfDay / 24 * Math.PI * 2) * 0.4),
                y: this.canvas.height * 0.15
            };
            
            // Stars visible at night
            starsVisible = true;
            
            // Night clouds
            cloudColor = 'rgba(40, 50, 80, 0.7)';
            cloudShadow = 'rgba(10, 10, 20, 0.5)';
            
        } else if (timeOfDay < 7 || timeOfDay > 19) {
            // Dawn/Dusk
            if (timeOfDay < 7) {
                // Dawn
                skyColor1 = '#2C3E50'; // Dark blue at the top
                skyColor2 = '#E74C3C'; // Reddish in the middle
                skyColor3 = '#F39C12'; // Orange-yellow toward horizon
                horizonColor = '#FFDB58'; // Yellow horizon glow
            } else {
                // Dusk
                skyColor1 = '#2C3E50'; // Dark blue at the top
                skyColor2 = '#E26A6A'; // Pinkish-red in the middle
                skyColor3 = '#FF8C42'; // Orange toward horizon
                horizonColor = '#FFC15E'; // Light orange horizon glow
            }
            
            // Sun/Moon position for dawn/dusk
            const angle = timeOfDay < 7 ? 
                          Math.PI - (timeOfDay / 7) * Math.PI : 
                          (timeOfDay - 19) / 5 * Math.PI;
                          
            sunMoonColor = '#FF8C42';
            sunMoonGlow = 'rgba(255, 140, 66, 0.4)';
            sunMoonSize = 50;
            sunMoonPosition = {
                x: this.canvas.width * (0.5 + Math.cos(angle) * 0.45),
                y: this.canvas.height * (0.4 + Math.sin(angle) * 0.3)
            };
            
            // Twilight clouds
            cloudColor = 'rgba(255, 190, 170, 0.8)';
            cloudShadow = 'rgba(60, 30, 40, 0.3)';
            
        } else {
            // Day
            skyColor1 = '#1E88E5'; // Bright blue at the top
            skyColor2 = '#64B5F6'; // Mid blue in the middle
            skyColor3 = '#90CAF9'; // Light blue toward horizon
            horizonColor = '#BBDEFB'; // Very light blue horizon glow
            
            // Sun position during day
            const angle = Math.PI + (timeOfDay - 12) / 12 * Math.PI;
            sunMoonColor = '#FFFDE7';
            sunMoonGlow = 'rgba(255, 253, 231, 0.6)';
            sunMoonSize = 60;
            sunMoonPosition = {
                x: this.canvas.width * (0.5 + Math.cos(angle) * 0.4),
                y: this.canvas.height * (0.3 + Math.sin(angle) * 0.2)
            };
            
            // Day clouds
            cloudColor = 'rgba(255, 255, 255, 0.9)';
            cloudShadow = 'rgba(100, 100, 100, 0.2)';
        }

        // Draw sky gradient with multiple color stops
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height / 2);
        gradient.addColorStop(0, skyColor1);
        gradient.addColorStop(0.4, skyColor2);
        gradient.addColorStop(0.8, skyColor3);
        gradient.addColorStop(1, horizonColor);
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height / 2);
        
        // Draw stars at night
        if (starsVisible) {
            this.renderStars();
        }
        
        // Draw sun/moon with glow effect
        if (sunMoonVisible) {
            // Outer glow
            const glowGradient = this.ctx.createRadialGradient(
                sunMoonPosition.x, sunMoonPosition.y, sunMoonSize * 0.5,
                sunMoonPosition.x, sunMoonPosition.y, sunMoonSize * 2
            );
            glowGradient.addColorStop(0, sunMoonGlow);
            glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            this.ctx.fillStyle = glowGradient;
            this.ctx.beginPath();
            this.ctx.arc(sunMoonPosition.x, sunMoonPosition.y, sunMoonSize * 2, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Sun/Moon body
            this.ctx.fillStyle = sunMoonColor;
            this.ctx.beginPath();
            this.ctx.arc(sunMoonPosition.x, sunMoonPosition.y, sunMoonSize, 0, Math.PI * 2);
            this.ctx.fill();
            
            // If it's the moon, add some crater details
            if (timeOfDay < 5 || timeOfDay > 21) {
                this.ctx.fillStyle = 'rgba(200, 200, 220, 0.4)';
                // Add a few random craters
                for (let i = 0; i < 5; i++) {
                    const craterX = sunMoonPosition.x + (Math.random() - 0.5) * sunMoonSize;
                    const craterY = sunMoonPosition.y + (Math.random() - 0.5) * sunMoonSize;
                    const craterSize = 2 + Math.random() * 6;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
        
        // Draw clouds
        this.renderClouds(cloudColor, cloudShadow);
    }
    
    private renderStars() {
        // Render stars in the night sky
        const starCount = 100;
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        
        // Use a deterministic approach so stars don't flicker
        const seed = Math.floor(this.gameState.camera.z / 1000);
        
        for (let i = 0; i < starCount; i++) {
            // Pseudorandom but stable positions
            const rng1 = Math.sin(i * 1.3 + seed) * 0.5 + 0.5;
            const rng2 = Math.cos(i * 2.7 + seed) * 0.5 + 0.5;
            
            const x = rng1 * this.canvas.width;
            const y = rng2 * (this.canvas.height * 0.4);
            const size = 1 + Math.sin(i * 3.1) * 1;
            
            // Twinkle effect
            const twinkle = 0.6 + Math.sin(i + this.gameState.distance * 0.01) * 0.4;
            
            this.ctx.globalAlpha = twinkle;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        this.ctx.globalAlpha = 1.0;
    }
    
    private renderClouds(cloudColor: string, cloudShadow: string) {
        // Render clouds in the sky
        const cloudCount = 6;
        const cloudBaseY = this.canvas.height * 0.25;
        
        // Use distance to create stable but moving clouds
        const seed = Math.floor(this.gameState.camera.z / 200);
        
        for (let i = 0; i < cloudCount; i++) {
            // Pseudorandom but stable positions
            const rng1 = Math.sin(i * 1.5 + seed * 0.1) * 0.5 + 0.5;
            const cloudX = ((rng1 * this.canvas.width * 1.5) - (this.canvas.width * 0.25)) % this.canvas.width;
            const cloudY = cloudBaseY - i * 15;
            const cloudWidth = 100 + Math.sin(i * 2.7) * 50;
            const cloudHeight = 30 + Math.sin(i * 3.5) * 20;
            
            // Cloud shadow
            this.ctx.fillStyle = cloudShadow;
            this.ctx.beginPath();
            this.ctx.ellipse(cloudX + 10, cloudY + 10, cloudWidth * 0.5, cloudHeight * 0.5, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Main cloud
            this.ctx.fillStyle = cloudColor;
            this.ctx.beginPath();
            this.ctx.ellipse(cloudX, cloudY, cloudWidth * 0.5, cloudHeight * 0.5, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cloud detail - multiple overlapping circles
            const detailCount = 5;
            for (let j = 0; j < detailCount; j++) {
                const detailX = cloudX + (Math.sin(j * 2.1) * cloudWidth * 0.3);
                const detailY = cloudY + (Math.cos(j * 1.7) * cloudHeight * 0.3);
                const detailSize = (0.3 + Math.sin(j * 3.1) * 0.2) * cloudWidth * 0.5;
                
                this.ctx.beginPath();
                this.ctx.arc(detailX, detailY, detailSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }
    }

    private renderMountains() {
        // Enhanced parallax mountains with multiple layers
        const layers = [
            { color: '#2d1b69', speed: 0.05, height: 150 },
            { color: '#8B4513', speed: 0.1, height: 100 },
            { color: '#CD853F', speed: 0.15, height: 80 }
        ];

        layers.forEach((layer, layerIndex) => {
            this.ctx.fillStyle = layer.color;
            this.ctx.beginPath();

            const mountainOffset = this.gameState.camera.z * layer.speed;
            const numMountains = 8;

            for (let i = 0; i <= numMountains; i++) {
                const x = ((i * 150 - mountainOffset) % (this.canvas.width + 300)) - 150;
                const height = layer.height + Math.sin(i + layerIndex) * 30;
                const baseY = this.canvas.height / 2 - layerIndex * 20;

                this.ctx.moveTo(x, baseY);
                this.ctx.lineTo(x + 75, baseY - height);
                this.ctx.lineTo(x + 150, baseY);
            }

            this.ctx.lineTo(this.canvas.width, this.canvas.height / 2);
            this.ctx.lineTo(0, this.canvas.height / 2);
            this.ctx.fill();
        });
    }

    private renderLandscape() {
        // Render procedurally generated landscape objects
        this.gameState.landscape.forEach(obj => {
            const relativeZ = obj.z - this.gameState.camera.z;

            if (relativeZ > 10 && relativeZ < 3000) {
                const projected = this.project3D(obj.x, obj.y, relativeZ);

                if (projected.z > 0) {
                    const scale = obj.scale * (this.CAMERA_DEPTH / projected.z);
                    const size = this.getObjectSize(obj.type) * scale;

                    this.ctx.fillStyle = this.getObjectColor(obj.type);
                    this.renderObject(obj.type, projected.x, projected.y, size);
                }
            }
        });
    }

    private getObjectSize(type: string): number {
        switch (type) {
            case 'tree': return 40;
            case 'house': return 60;
            case 'bush': return 20;
            default: return 30;
        }
    }

    private getObjectColor(type: string): string {
        switch (type) {
            case 'tree': return '#228B22';
            case 'house': return '#8B4513';
            case 'bush': return '#32CD32';
            default: return '#666';
        }
    }    private renderObject(type: string, x: number, y: number, size: number) {
        this.ctx.save();
        this.ctx.translate(x, y);

        switch (type) {
            case 'tree':
                // Enhanced tree with more realistic appearance
                
                // Tree trunk with gradient for depth
                const trunkGradient = this.ctx.createLinearGradient(-size * 0.1, 0, size * 0.1, 0);
                trunkGradient.addColorStop(0, '#5D4037');
                trunkGradient.addColorStop(0.5, '#8B4513');
                trunkGradient.addColorStop(1, '#5D4037');
                
                this.ctx.fillStyle = trunkGradient;
                this.ctx.fillRect(-size * 0.1, 0, size * 0.2, size * 0.7);
                
                // Tree shadow
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, size * 0.7, size * 0.3, size * 0.1, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Multiple layers of foliage for depth
                const foliageColors = ['#1B5E20', '#2E7D32', '#388E3C', '#43A047'];
                
                // Create pine tree shape with triangular layers
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = foliageColors[i % foliageColors.length];
                    this.ctx.beginPath();
                    this.ctx.moveTo(-size * (0.4 - i * 0.05), -size * (i * 0.2));
                    this.ctx.lineTo(0, -size * (0.6 + i * 0.15));
                    this.ctx.lineTo(size * (0.4 - i * 0.05), -size * (i * 0.2));
                    this.ctx.fill();
                }
                break;

            case 'house':
                // Enhanced house with windows, door, and more details
                
                // House shadow
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, size * 0.2, size * 0.5, size * 0.1, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // House base with varying colors
                const houseColor = Math.random() > 0.5 ? '#D7CCC8' : '#BCAAA4';
                this.ctx.fillStyle = houseColor;
                this.ctx.fillRect(-size * 0.4, -size * 0.3, size * 0.8, size * 0.5);
                
                // House roof with gradient
                const roofGradient = this.ctx.createLinearGradient(0, -size * 0.7, 0, -size * 0.3);
                roofGradient.addColorStop(0, '#BF360C');
                roofGradient.addColorStop(1, '#E64A19');
                
                this.ctx.fillStyle = roofGradient;
                this.ctx.beginPath();
                this.ctx.moveTo(-size * 0.5, -size * 0.3);
                this.ctx.lineTo(0, -size * 0.7);
                this.ctx.lineTo(size * 0.5, -size * 0.3);
                this.ctx.fill();
                
                // Windows
                this.ctx.fillStyle = '#B3E5FC';
                this.ctx.fillRect(-size * 0.3, -size * 0.2, size * 0.2, size * 0.2);
                this.ctx.fillRect(size * 0.1, -size * 0.2, size * 0.2, size * 0.2);
                
                // Window frames
                this.ctx.strokeStyle = '#546E7A';
                this.ctx.lineWidth = size * 0.02;
                this.ctx.strokeRect(-size * 0.3, -size * 0.2, size * 0.2, size * 0.2);
                this.ctx.strokeRect(size * 0.1, -size * 0.2, size * 0.2, size * 0.2);
                
                // Door
                this.ctx.fillStyle = '#5D4037';
                this.ctx.fillRect(-size * 0.05, -size * 0.1, size * 0.1, size * 0.3);
                
                // Door knob
                this.ctx.fillStyle = '#FFC107';
                this.ctx.beginPath();
                this.ctx.arc(size * 0.02, 0, size * 0.02, 0, Math.PI * 2);
                this.ctx.fill();
                break;

            case 'bush':
                // Enhanced bush with multiple layers for depth
                
                // Bush shadow
                this.ctx.fillStyle = 'rgba(0,0,0,0.15)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, size * 0.3, size * 0.3, size * 0.1, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Multiple bush clusters
                const bushColors = ['#2E7D32', '#388E3C', '#43A047', '#66BB6A'];
                
                for (let i = 0; i < 4; i++) {
                    this.ctx.fillStyle = bushColors[i % bushColors.length];
                    this.ctx.beginPath();
                    const offsetX = (Math.random() - 0.5) * size * 0.3;
                    const offsetY = (Math.random() - 0.5) * size * 0.3;
                    const radius = (0.3 + Math.random() * 0.2) * size * 0.5;
                    this.ctx.arc(offsetX, offsetY, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                break;
                
            case 'sea':
                // Sea with waves and reflections
                
                // Base water color gradient
                const waterGradient = this.ctx.createLinearGradient(-size, 0, size, 0);
                waterGradient.addColorStop(0, '#0277BD');
                waterGradient.addColorStop(0.5, '#039BE5');
                waterGradient.addColorStop(1, '#0277BD');
                
                this.ctx.fillStyle = waterGradient;
                this.ctx.beginPath();
                
                // Create waves with sine function
                this.ctx.moveTo(-size, 0);
                for (let i = -size; i <= size; i += 10) {
                    const waveHeight = Math.sin(i * 0.05) * size * 0.1;
                    this.ctx.lineTo(i, waveHeight);
                }
                this.ctx.lineTo(size, 0);
                this.ctx.lineTo(size, size * 0.5);
                this.ctx.lineTo(-size, size * 0.5);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Add wave highlights
                this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for (let i = -size; i <= size; i += 30) {
                    const startX = i;
                    const startY = Math.sin(i * 0.05) * size * 0.1;
                    const endX = i + 15;
                    const endY = Math.sin((i + 15) * 0.05) * size * 0.1;
                    
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(endX, endY);
                }
                this.ctx.stroke();
                break;
                
            case 'mountain':
                // Enhanced mountain with detail and snow cap
                const mountainGradient = this.ctx.createLinearGradient(0, -size, 0, 0);
                mountainGradient.addColorStop(0, '#546E7A'); // Mountain top
                mountainGradient.addColorStop(0.3, '#37474F'); // Upper part
                mountainGradient.addColorStop(1, '#263238'); // Base
                
                // Mountain shape with rougher edges
                this.ctx.fillStyle = mountainGradient;
                this.ctx.beginPath();
                this.ctx.moveTo(-size, 0);
                
                // Left side of mountain
                for (let i = 0; i <= 5; i++) {
                    const xPoint = -size + i * size / 5;
                    const noiseY = Math.sin(i * 5) * size * 0.1;
                    const heightFactor = 1 - Math.abs((i / 5) - 0.5) * 2; // Highest in the middle
                    const yPoint = -size * heightFactor * 0.7 + noiseY;
                    this.ctx.lineTo(xPoint, yPoint);
                }
                
                // Mountain peak
                this.ctx.lineTo(0, -size * 0.8);
                
                // Right side of mountain
                for (let i = 0; i <= 5; i++) {
                    const xPoint = size - i * size / 5;
                    const noiseY = Math.sin(i * 5) * size * 0.1;
                    const heightFactor = 1 - Math.abs((i / 5) - 0.5) * 2;
                    const yPoint = -size * heightFactor * 0.6 + noiseY;
                    this.ctx.lineTo(xPoint, yPoint);
                }
                
                this.ctx.lineTo(size, 0);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Snow cap on mountain top
                this.ctx.fillStyle = '#ECEFF1';
                this.ctx.beginPath();
                this.ctx.moveTo(-size * 0.3, -size * 0.65);
                this.ctx.lineTo(0, -size * 0.8);
                this.ctx.lineTo(size * 0.3, -size * 0.6);
                this.ctx.lineTo(size * 0.2, -size * 0.5);
                this.ctx.lineTo(-size * 0.2, -size * 0.55);
                this.ctx.closePath();
                this.ctx.fill();
                break;
                
            case 'grass':
                // Grass tufts
                const grassColors = ['#66BB6A', '#4CAF50', '#43A047', '#388E3C'];
                
                for (let i = 0; i < 12; i++) {
                    const offsetX = (Math.random() - 0.5) * size;
                    const height = size * (0.3 + Math.random() * 0.2);
                    
                    this.ctx.fillStyle = grassColors[Math.floor(Math.random() * grassColors.length)];
                    this.ctx.beginPath();
                    this.ctx.moveTo(offsetX, 0);
                    
                    // Curved blade of grass
                    const controlX1 = offsetX + (Math.random() - 0.5) * size * 0.3;
                    const controlY1 = -height * 0.6;
                    const controlX2 = offsetX + (Math.random() - 0.5) * size * 0.3;
                    const controlY2 = -height * 0.8;
                    const endX = offsetX + (Math.random() - 0.5) * size * 0.2;
                    const endY = -height;
                    
                    this.ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, endX, endY);
                    this.ctx.bezierCurveTo(controlX2, controlY2, controlX1, controlY1, offsetX, 0);
                    this.ctx.fill();
                }
                break;
        }

        this.ctx.restore();
    }    private renderRoad() {
        const baseSegment = Math.floor(this.gameState.camera.z / this.SEGMENT_LENGTH);        // Store positions for adjacent segments to create a more connected road
        let lastSegmentPositions = [];

        for (let n = 0; n < this.DRAW_DISTANCE; n++) {
            const segment = this.gameState.road[(baseSegment + n) % this.gameState.road.length];

            const projectedY = this.project3D(
                0,
                this.CAMERA_HEIGHT,
                segment.worldY - this.gameState.camera.z
            );

            if (projectedY.z > 0) {
                const scale = this.CAMERA_DEPTH / projectedY.z;
                const roadWidth = this.ROAD_WIDTH * scale;
                const roadX = this.canvas.width / 2;
                const segmentHeight = scale * 20;

                // Compute x offset for curved road sections
                const curve = segment.curve * scale * 2;
                const curvedX = roadX + curve * 1000; // Amplify the curve effect

                // Road side environment - grass with texture
                const grassColor = n % 2 === 0 ? '#1a8f1a' : '#228B22'; // Alternating grass colors
                this.ctx.fillStyle = grassColor;
                this.ctx.fillRect(0, projectedY.y, this.canvas.width, segmentHeight);

                // Rumble strips on edges (red and white)
                const rumbleWidth = 8 * scale;
                this.ctx.fillStyle = n % 2 === 0 ? '#f00' : '#fff';
                this.ctx.fillRect(curvedX - roadWidth / 2 - rumbleWidth, projectedY.y, rumbleWidth, segmentHeight);
                this.ctx.fillRect(curvedX + roadWidth / 2, projectedY.y, rumbleWidth, segmentHeight);

                // Road shoulder (darker than road)
                const shoulderWidth = 15 * scale;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(curvedX - roadWidth / 2 - shoulderWidth, projectedY.y, shoulderWidth, segmentHeight);
                this.ctx.fillRect(curvedX + roadWidth / 2 - shoulderWidth, projectedY.y, shoulderWidth, segmentHeight);

                // Main road surface with gradient for 3D effect
                const gradient = this.ctx.createLinearGradient(
                    curvedX - roadWidth / 2, projectedY.y,
                    curvedX + roadWidth / 2, projectedY.y
                );

                // Base road color with alternating pattern for depth perception
                const roadColorLight = n % 2 === 0 ? '#888' : '#777';
                const roadColorDark = n % 2 === 0 ? '#666' : '#555';
                
                gradient.addColorStop(0, roadColorDark);
                gradient.addColorStop(0.5, roadColorLight);
                gradient.addColorStop(1, roadColorDark);
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(
                    curvedX - roadWidth / 2,
                    projectedY.y,
                    roadWidth,
                    segmentHeight
                );

                // Road edges - solid white lines
                this.ctx.fillStyle = '#fff';
                this.ctx.fillRect(curvedX - roadWidth / 2, projectedY.y, 4 * scale, segmentHeight);
                this.ctx.fillRect(curvedX + roadWidth / 2 - 4 * scale, projectedY.y, 4 * scale, segmentHeight);

                // Center line stripes
                if (n % 4 === 0) { // More frequent lane markers for better visibility
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.fillRect(
                        curvedX - 6 * scale,
                        projectedY.y,
                        12 * scale,
                        segmentHeight * 0.6
                    );
                }

                // Add lanes (for multi-lane road)
                const numLanes = 2;
                const laneWidth = roadWidth / numLanes;
                
                // Draw lane markers
                for (let lane = 1; lane < numLanes; lane++) {
                    const laneX = curvedX - roadWidth / 2 + lane * laneWidth;
                    
                    if (n % 6 === 0) { // Dashed lane lines
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillRect(
                            laneX - 2 * scale,
                            projectedY.y,
                            4 * scale,
                            segmentHeight * 0.6
                        );
                    }                }
                
                // Store segment position for potential use with 3D effects
                lastSegmentPositions.push({ x: curvedX, y: projectedY.y, width: roadWidth });
            }
        }
    } private renderCar() {
        const carX = this.canvas.width / 2 + this.gameState.car.position.x * 100;
        const carY = this.canvas.height * 0.8;
        const carWidth = 60;  // Slightly wider for the sprite
        const carHeight = 30; // Slightly taller for the sprite

        if (this.gameState.car.sprite) {
            // If we have a sprite loaded, use it
            try {
                // Draw the car shadow
                this.ctx.save();
                this.ctx.translate(carX, carY + 15);
                this.ctx.scale(0.8, 0.2);
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, carWidth * 0.8, carHeight, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();

                // Apply a slight tilt effect based on steering direction
                this.ctx.save();
                this.ctx.translate(carX, carY);
                this.ctx.rotate(this.gameState.car.steerDirection * 0.05);

                // Draw the main sprite
                this.ctx.drawImage(
                    this.gameState.car.sprite,
                    -carWidth, -carHeight,
                    carWidth * 2, carHeight * 2
                );

                // Add brake light effect when braking
                if (this.controls.brake) {
                    this.ctx.fillStyle = 'rgba(255, 60, 60, 0.8)';
                    this.ctx.fillRect(-carWidth * 0.8, carHeight * 0.6, carWidth * 0.2, carHeight * 0.2);
                    this.ctx.fillRect(carWidth * 0.6, carHeight * 0.6, carWidth * 0.2, carHeight * 0.2);
                }

                this.ctx.restore();
            } catch (e) {
                console.error('Error rendering car sprite:', e);
                this.renderFallbackCar(carX, carY, carWidth, carHeight);
            }
        } else {
            // Fallback rendering if sprite isn't loaded yet
            this.renderFallbackCar(carX, carY, carWidth, carHeight);
        }
    }

    private renderFallbackCar(carX: number, carY: number, carWidth: number, carHeight: number) {
        // Car shadow
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(carX - carWidth / 2 + 2, carY + carHeight / 2 + 2, carWidth, 4);

        // Main car body
        this.ctx.fillStyle = '#ff0000';
        this.ctx.fillRect(carX - carWidth / 2, carY - carHeight / 2, carWidth, carHeight);

        // Car highlights
        this.ctx.fillStyle = '#ffdddd';
        this.ctx.fillRect(carX - carWidth / 2 + 5, carY - carHeight / 2 + 2, carWidth - 10, 3);

        // Car windows
        this.ctx.fillStyle = '#87CEEB';
        this.ctx.fillRect(carX - carWidth / 2 + 8, carY - carHeight / 2 + 6, carWidth - 16, 8);

        // Wheels
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(carX - carWidth / 2 + 5, carY + carHeight / 2 - 2, 8, 4);
        this.ctx.fillRect(carX + carWidth / 2 - 13, carY + carHeight / 2 - 2, 8, 4);

        // Brake lights when braking
        if (this.controls.brake) {
            this.ctx.fillStyle = '#ff6666';
            this.ctx.fillRect(carX - carWidth / 2 + 2, carY + carHeight / 2 - 8, 4, 6);
            this.ctx.fillRect(carX + carWidth / 2 - 6, carY + carHeight / 2 - 8, 4, 6);
        }
    } private renderHUD() {
        // HUD Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(10, 10, 220, 120);

        // Border
        this.ctx.strokeStyle = '#00ffff';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(10, 10, 220, 120);

        // Text styling
        this.ctx.fillStyle = '#00ffff';
        this.ctx.font = 'bold 18px Arial';
        this.ctx.fillText(`SPEED: ${Math.floor(this.gameState.car.speed)} KM/H`, 20, 35);

        this.ctx.fillStyle = '#ffff00';
        this.ctx.fillText(`SCORE: ${this.gameState.score}`, 20, 60);

        this.ctx.fillStyle = '#ff69b4';
        this.ctx.fillText(`DISTANCE: ${Math.floor(this.gameState.distance)}M`, 20, 85);

        // Keyboard controls hint
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        this.ctx.font = '12px Arial';
        this.ctx.fillText(`A/D or ← → to steer, Space to brake, P to pause`, 20, 105);

        // Speed meter
        const meterX = this.canvas.width - 120;
        const meterY = 60;
        const meterRadius = 40;

        // Meter background
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 8;
        this.ctx.beginPath();
        this.ctx.arc(meterX, meterY, meterRadius, Math.PI, 2 * Math.PI);
        this.ctx.stroke();

        // Speed arc
        const speedRatio = this.gameState.car.speed / this.gameState.car.maxSpeed;
        const speedAngle = Math.PI + speedRatio * Math.PI;

        this.ctx.strokeStyle = speedRatio > 0.8 ? '#ff0000' : speedRatio > 0.6 ? '#ffff00' : '#00ff00';
        this.ctx.lineWidth = 6;
        this.ctx.beginPath();
        this.ctx.arc(meterX, meterY, meterRadius, Math.PI, speedAngle);
        this.ctx.stroke();
    }

    private project3D(x: number, y: number, z: number) {
        const scale = this.CAMERA_DEPTH / (z + this.CAMERA_DEPTH);
        return {
            x: this.canvas.width / 2 + (x - this.gameState.camera.x) * scale,
            y: this.canvas.height / 2 - y * scale,
            z: z + this.CAMERA_DEPTH
        };
    }

    public getGameState(): GameState {
        return this.gameState;
    }
}
